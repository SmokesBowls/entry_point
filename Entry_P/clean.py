#!/usr/bin/env python3
"""
clean.py -- Surgery phase (consumes scan artifact)

Loads reports/usage_index.json and performs pruning or quarantine operations.
No scanning, no tracing, no static analysis. Just reads the artifact and acts.

Usage:
    python3 clean.py /path/to/repo --quarantine
    python3 clean.py /path/to/repo --prune
    python3 clean.py /path/to/repo --quarantine --prune

Requires: reports/usage_index.json (generated by scan.py or main.py)
"""
import argparse
import json
import sys
from pathlib import Path


def main():
    parser = argparse.ArgumentParser(
        description="Repository Integrity Engine -- Clean phase: quarantine or prune using scan results.",
        epilog="Requires reports/usage_index.json. Run 'python3 scan.py' first."
    )
    parser.add_argument("repo", nargs="?", default=".", help="Path to the repository (must match scan target)")
    parser.add_argument("--prune", action="store_true", help="Generate safe pruning plan and script")
    parser.add_argument("--quarantine", action="store_true", help="Generate quarantine plan with tiered move/restore")
    parser.add_argument("--report", help="Path to usage_index.json (default: repo/reports/usage_index.json)")

    args = parser.parse_args()

    if not args.prune and not args.quarantine:
        parser.error("Specify at least one action: --prune or --quarantine")

    repo_root = Path(args.repo).resolve()
    report_path = Path(args.report) if args.report else repo_root / "reports" / "usage_index.json"

    if not report_path.exists():
        print(f"Error: Report not found at {report_path}")
        print(f"Run 'python3 scan.py {repo_root}' first to generate the scan artifact.")
        return 1

    print(f"--- Repository Integrity Engine: Clean Phase ---")
    print(f"Repo: {repo_root}")
    print(f"Artifact: {report_path}")

    with open(report_path, "r") as f:
        data = json.load(f)

    # Extract data structures from the JSON artifact
    file_data = data.get("layer_1_evidence", {}).get("files", [])
    if not file_data:
        print("Error: No file data in report. Re-run scan.py to regenerate.")
        return 1

    # Graph adjacency list (dict of node -> [neighbors])
    graph_raw = data.get("layer_2_structure", {}).get("graph", {})
    # Convert lists back to sets for engine compatibility
    graph = {k: set(v) for k, v in graph_raw.items()}
    if not graph:
        print("Warning: No graph data in report. Surgery will use file list only.")
        print("(Re-run scan.py to include graph in report)")

    classified_entrypoints = data.get("phase4_entrypoints", {}).get("classified", [])
    engine_scopes = data.get("metadata", {}).get("engine_scope", ["."])

    print(f"Loaded: {len(file_data)} files, {len(graph)} graph nodes, "
          f"{len(classified_entrypoints)} entrypoints")

    # Run surgery via main.run_clean
    from main import run_clean
    run_clean(
        repo_root, file_data, graph, classified_entrypoints, engine_scopes,
        prune=args.prune,
        quarantine=args.quarantine,
    )

    print("[OK] Clean phase complete.")
    return 0


if __name__ == "__main__":
    sys.exit(main() or 0)
